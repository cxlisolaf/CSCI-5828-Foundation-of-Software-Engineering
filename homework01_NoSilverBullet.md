# Homework1: No Silver Bullet reading report
***
### Name: Xiaolan Cai



- Define the term essential difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.

    Brooks defines the essential difficulties as the difficulties inherent in the nature of software. 
    
    He thinks the essence of a software entity is a construct of interlocking concepts: data sets, relationships among data items, algorithms, and invocations of functions. This essence is abstract in that such a conceptual construct is the same under many different representations. It is nonetheless highly precise and richly detailed. Brooks believes the hard part of building software to be the specification, design, and testing of this conceptual construct, not the labor of representing it and testing the fidelity of the representation. The syntax errors are fuzz compared with the conceptual errors in most systems. If this is true, building software will always be hard and inherently no silver bullet to solve. 
    
    For example,  complexity property of software comes with the difficulty of communication among team members, which leads to product flaws, cost overruns, schedule delays.

***

- Define the term accidental difficulties as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty. 

    Brooks defined the accidental difficulties as those difficulties that today attend its production but are not inherent.  Brooks argues that if we examine the three steps in software technology development that have been most fruitful in the past, we discover that each attacked a different major difficulty in building software, but that those difficulties have been accidental, not essential, difficulties.
    
    For example, the slow turnaround is an accidental rather than an essential difficulty of the software process. The slow turnaround of batch programming means that one inevitably forgets the minutiae, if not the very thrust, of what one was thinking when he stopped programming and called for compilation and execution. This interruption is costly in time, for one must refresh one's memory. The most serious effect may well be the decay of the grasp of all that is going on in a complex system. 

***
- List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.

    The four essential difficulties of developing software systems are:
    
    Complexity:
    
    The fact that digital computers have very large numbers of states. This makes conceiving, describing, and testing them hard. Software systems have orders-of- magnitude more states than computers do. have very large numbers of states. This makes conceiving, describing, and testing them hard. Software systems have orders-of- magnitude more states than computers do.
    
    Conformity:
    
    The fact that much of the complexity that must master is arbitrary complexity, forced without rhyme or reason by the many human institutions and systems to which the interfaces must conform. These differ from interface to interface, and from time to time, not because of necessity but only because they were designed by different people, rather than by God.
    
    Changeability:
    
    The fact that the software entity is constantly subject to pressures for change. In short, the software product is embedded in a cultural matrix of applications, users, laws, and machine vehicles. These all change continually, and their changes inexorably force change upon the software product.

    
    Invisibility:
    
Software is invisible and unvisualizable. Hence, it has no ready geometric representation in the way that land has maps, silicon chips have diagrams, computers have connectivity schematics.


***
- Define what Brooks means by a silver bullet and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

***
- In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.

***
- In lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.


